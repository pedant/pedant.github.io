<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>如何让WebView中JS与Java安全地相互调用 | 书呆子精神院</title>
  <meta name="author" content="Yanyuetian">
  
  <meta name="description" content="在现在安卓应用原生开发中，为了追求开发的效率以及移植的便利性，使用WebView作为业务内容展示与交互的主要载体是个不错的折中方案。那么在这种Hybrid(混合式) App中，难免就会遇到页面JS需要与Java相互调用，调用Java方法去做那部分网页JS不能完成的功能。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="如何让WebView中JS与Java安全地相互调用"/>
  <meta property="og:site_name" content="书呆子精神院"/>

  
    <meta property="og:image" content="undefined"/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://www.pedant.cn/2014/07/04/webview-js-java-interface-research/" />
  <link rel="alternate" href="/atom.xml" title="书呆子精神院" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">书呆子精神院</a></h1>
  <h2>一起发呆，一起发疯</h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
    <li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper"><article class="android">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-07-04T06:53:54.000Z"><a href="/2014/07/04/webview-js-java-interface-research/">7月04 2014</a></time>
      
      
  
    <h1 class="title">如何让WebView中JS与Java安全地相互调用</h1>
  

    </header>
    <div class="entry">
      
        <p>在现在安卓应用原生开发中，为了追求开发的效率以及移植的便利性，使用WebView作为业务内容展示与交互的主要载体是个不错的折中方案。那么在这种Hybrid(混合式) App中，难免就会遇到页面JS需要与Java相互调用，调用Java方法去做那部分网页JS不能完成的功能。</p>
<a id="more"></a>

<p>网上的方法可以告诉我们这个时候我们可以使用<strong>addjavascriptInterface</strong>来注入原生接口到JS中，但是在安卓4.2以下的系统中，这种方案却我们的应用带来了很大的安全风险。攻击者如果在页面执行一些非法的JS（诱导用户打开一些钓鱼网站以进入风险页面），极有可能反弹拿到用户手机的shell权限。接下来攻击者就可以在后台默默安装木马，完全洞穿用户的手机。详细的攻击过程可以见乌云平台的这份报告：<a href="http://drops.wooyun.org/papers/548" target="_blank" rel="external">WebView中接口隐患与手机挂马利用</a>。</p>
<p>安卓4.2及以上版本（API &gt;= 17），在注入类中为可调用的方法添加@JavascriptInterface注解，无注解的方法不能被调用，这种方式可以防范注入漏洞。那么有没一种安全的方式，可以完全兼顾安卓4.2以下版本呢？答案就是使用prompt，即WebChromeClient 输入框弹出模式。</p>
<p>我们参照 <a href="http://blog.csdn.net/leehong2005/article/details/11808557" target="_blank" rel="external">Android WebView的Js对象注入漏洞解决方案</a> 这篇文章给出的解决方案， 但它JS下的方法有点笨拙， 动态生成JS文件过程也并没有清晰，且加载JS文件的时机也没有准确把握。那么如何改造才能便利地在JS代码中调用Java方法，并且安全可靠呢？</p>
<h3 id="一、动态地生成将注入的JS代码">一、动态地生成将注入的JS代码</h3>
<p>这个时候，我们利用Java反射机制，将要注入的类（cn.pedant.SafeJava4WebviewJS.webview.bridge.HostJsScope）的public且static方法拿出来，并获取该方法的参数个数，结合静态的HostApp Javascript代码动态生成一段将要注入到webview中的字符串。</p>
<figure class="highlight JAVA"><figcaption><span>JsCallJava.java</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span> () {
    <span class="keyword">try</span> {
        Class&lt;?&gt; SCOPECLASS = Class.forName(<span class="string">"cn.pedant.SafeJava4WebviewJS.webview.bridge.HostJsScope"</span>);
        mMethodMap = <span class="keyword">new</span> HashMap&lt;String, Method&gt;();
        <span class="comment">//获取自身声明的所有方法（包括public private protected）， getMethods会获得所有继承与非继承的方法</span>
        Method[] methods = SCOPECLASS.getDeclaredMethods();
        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"javascript:(function(e){console.log(\"HostApp initialization begin\");var f={queue:[],callback:function(){var a=Array.prototype.slice.call(arguments,0);var b=a.shift();var c = a.shift();this.queue[b].apply(this,a);if(!c)delete this.queue[b]}};"</span>);
        String methodName;
        <span class="keyword">for</span> (Method method : methods) {
            <span class="comment">//非公用静态方法，直接跳过</span>
            <span class="keyword">if</span> (method.getModifiers() != (Modifier.PUBLIC | Modifier.STATIC)) {
                <span class="keyword">continue</span>;
            }
            methodName = method.getName();
            mMethodMap.put(keyConcat(methodName, method.getParameterTypes().length), method);
            sb.append(String.format(<span class="string">"f.%s="</span>, methodName));
        }
        sb.append(<span class="string">"function(){var a=Array.prototype.slice.call(arguments,0);if(a.length&lt;1){throw\"HostApp call error, message:miss method name\";}for(var i=1;i&lt;a.length;i++){var b=a[i];if(typeof b==\"function\"){var c=f.queue.length;f.queue[c]=b;a[i]=c}}var d=JSON.parse(prompt(JSON.stringify({method:a.shift(),args:a})));if(d.code!=200){throw\"HostApp call error, code:\"+d.code+\", message:\"+d.result;}return d.result};Object.getOwnPropertyNames(f).forEach(function(a){var b=f[a];if(typeof b==='function'&&a!=='callback'){f[a]=function(){return b.apply(f,[a].concat(Array.prototype.slice.call(arguments,0)))}}});e.HostApp=f;console.log(\"HostApp initialization end\")})(window);"</span>);
        PRELOAD_INTERFACE_JS = sb.toString();
    } <span class="keyword">catch</span>(Exception e){
        Log.e(<span class="string">"init js error:"</span> + e.getMessage());
    }
}

<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">keyConcat</span> (String name, <span class="keyword">int</span> len) {
    <span class="keyword">return</span> name + <span class="string">"_"</span> + len;
}
</pre></td></tr></table></figure>

<p>从上面可以看出，类的方法及参数信息被拼接到前后两段静态JS代码当中，那么这样生成的JS完整片段会是怎样的呢？ 我们假设HostJsScope类中目前只定义了toast、alert、getIMSI这三个公开静态方法。</p>
<figure class="highlight JAVASCRIPT"><figcaption><span>HostApp JS片段</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre>(<span class="function"><span class="keyword">function</span><span class="params">(global)</span>{</span>
    console.log(<span class="string">"HostApp initialization begin"</span>);
    <span class="keyword">var</span> hostApp = {
        queue: [],
        callback: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);
            <span class="keyword">var</span> index = args.shift();
            <span class="keyword">var</span> isPermanent = args.shift();
            <span class="keyword">this</span>.queue[index].apply(<span class="keyword">this</span>, args);
            <span class="keyword">if</span> (!isPermanent) {
                <span class="keyword">delete</span> <span class="keyword">this</span>.queue[index];
            }
        }
    };
    hostApp.toast = hostApp.alert = hostApp.getIMSI = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);
        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) {
            <span class="keyword">throw</span> <span class="string">"HostApp call error, message:miss method name"</span>;
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; args.length;i++) {
            <span class="keyword">var</span> arg = args[i];
            <span class="keyword">if</span> (<span class="keyword">typeof</span> arg == <span class="string">"function"</span>) {
                <span class="keyword">var</span> index = hostApp.queue.length;
                hostApp.queue[index] = arg;
                args[i] = index;
            }
        }
        <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(prompt(<span class="built_in">JSON</span>.stringify({
            method: args.shift(),
            args: args
        })));

        <span class="keyword">if</span> (res.code != <span class="number">200</span>) {
            <span class="keyword">throw</span> <span class="string">"HostApp call error, code:"</span> + res.code + <span class="string">", message:"</span> + res.result;
        }
        <span class="keyword">return</span> res.result;
    };

    <span class="comment">//有时候，我们希望在该方法执行前插入一些其他的行为用来检查当前状态或是监测</span>
    <span class="comment">//代码行为，这就要用到拦截（Interception）或者叫注入（Injection）技术了</span>
    <span class="comment">/**
     * Object.getOwnPropertyName 返回一个数组，内容是指定对象的所有属性
     *
     * 其后遍历这个数组，分别做以下处理：
     * 1. 备份原始属性；
     * 2. 检查属性是否为 function（即方法）；
     * 3. 若是重新定义该方法，做你需要做的事情，之后 apply 原来的方法体。
     */</span>
    <span class="built_in">Object</span>.getOwnPropertyNames(hostApp).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(property)</span> {</span>
        <span class="keyword">var</span> original = hostApp[property];

        <span class="keyword">if</span> (<span class="keyword">typeof</span> original === <span class="string">'function'</span>&&property!==<span class="string">"callback"</span>) {
            hostApp[property] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">return</span> original.apply(hostApp,  [property].concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)));
            };
        }
    });
    global.HostApp = hostApp;
    console.log(<span class="string">"HostApp initialization end"</span>);
})(window);
</pre></td></tr></table></figure>

<p>其实初始化时我们拼动态生成的只是上面第15行 <em>hostApp.toast = hostApp.alert = hostApp.getIMSI = function ()</em> 这段。目的是将所有JS层调用函数嫁接到一个匿名函数1中，而后利用拦截技术，遍历hostApp下所有的函数，拿出对应的函数名，然后将函数嫁接到另一个匿名函数2，这样做的目的是hostApp下函数调用时首先执行匿名函数2，匿名函数2将对应的函数名作为第一个参数然后再调用匿名函数1，这样匿名函数1中就能区分执行时调用来源。实现了JS层<strong>调用入口统一，返回出口统一</strong>的结构体系。</p>
<h3 id="二、HostApp_JS片段注入时机">二、HostApp JS片段注入时机</h3>
<p>步骤一说明了HostApp JS片段的拼接方法，而HostApp JS片段拼接的时机是在Application启动时。</p>
<figure class="highlight JAVA"><figcaption><span>MainApp.java</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> <span class="keyword">extends</span> <span class="title">Application</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span>() {
        <span class="keyword">if</span> (gMainApp != <span class="keyword">null</span>) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">super</span>.onCreate();
        TaskExecutor.executeTask(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                <span class="comment">// 拼接HostApp JS片段</span>
                JsCallJava.init();
            }
        });
    }
}
</pre></td></tr></table></figure><br>从上面的代码，我们知道HostApp JS拼接出来的字符串暂时被放到PRELOAD_INTERFACE_JS静态变量中的。那么我们何时把这段拼接好的字符串注入到Webview的执行空间内呢？答案是页面加载进度变化的过程中。<br><figure class="highlight JAVA"><figcaption><span>BaseWebChromeClient.java</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span> (WebView view, <span class="keyword">int</span> newProgress) {
    BaseWebView baseWebView = (BaseWebView)view;
    <span class="comment">//为什么要在这里注入JS</span>
    <span class="comment">//1 OnPageStarted中注入有可能全局注入不成功，导致页面脚本上所有接口任何时候都不可用</span>
    <span class="comment">//2 OnPageFinished中注入，虽然最后都会全局注入成功，但是完成时间有可能太晚，当页面在初始化调用接口函数时会等待时间过长</span>
    <span class="comment">//3 在进度变化时注入，刚好可以在上面两个问题中得到一个折中处理</span>
    <span class="comment">//为什么是进度大于25%才进行注入，因为从测试看来只有进度大于这个数字页面才真正得到框架刷新加载，保证100%注入成功</span>
    <span class="keyword">if</span> (newProgress &gt; <span class="number">25</span> && !baseWebView.isInjectedJS()) {
        baseWebView.loadJS(JsCallJava.PRELOAD_INTERFACE_JS);
        baseWebView.setIsInjectedJS(<span class="keyword">true</span>);
        Log.d(<span class="string">" inject js interface completely on progress "</span> + newProgress);
    }
    <span class="keyword">super</span>.onProgressChanged(view, newProgress);
}
</pre></td></tr></table></figure>

<p>从上面我们可以看出，注入的时机是准确把握在进度大于25%时。如果在OnPageFinished注入，页面document.ready的初始回调会等待时间过长，详细的原因我们会在后面讲到。</p>
<h3 id="三、页面调用执行Java方法的过程">三、页面调用执行Java方法的过程</h3>
<p>OK，上面两步解决了动态生成与成功注入的两大问题，接下来就要处理JS具体的调用过程。上面，我们知道页面调用Java方法时，匿名js函数在拼接好参数后prompt json数据。prompt消息被Java层的WebChromeClient.onJsPrompt拦截到。</p>
<figure class="highlight JAVA"><figcaption><span>BaseWebChromeClient.java</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsPrompt</span>(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
    result.confirm(JsCallJava.call(view, message));
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<p>而JsCallJava.call的具体实现如下。</p>
<figure class="highlight JAVA"><figcaption><span>JsCallJava.java</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">call</span>(WebView webView, String jsonStr) {
    <span class="keyword">if</span> (!TextUtils.isEmpty(jsonStr)) {
        <span class="keyword">try</span> {
            JSONObject callJson = <span class="keyword">new</span> JSONObject(jsonStr);
            String methodName = callJson.getString(<span class="string">"method"</span>);
            JSONArray argsJson = callJson.getJSONArray(<span class="string">"args"</span>);
            <span class="comment">//带上默认的第一个参数WebView</span>
            <span class="keyword">int</span> argsLen = argsJson.length() + <span class="number">1</span>;
            Method currMethod = mMethodMap.get(keyConcat(methodName, argsLen));
            <span class="keyword">if</span> (currMethod == <span class="keyword">null</span>) {
                <span class="keyword">return</span> getReturn(jsonStr, <span class="number">500</span>, <span class="string">"not found method "</span> + methodName + <span class="string">" with "</span> + argsLen + <span class="string">" parameters"</span>);
            }
            Object[] args = <span class="keyword">new</span> Object[argsLen];
            Class[] types = currMethod.getParameterTypes();
            <span class="keyword">int</span> defValue = <span class="number">0</span>;
            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; argsLen;k++) {
                Class currType = types[k];
                <span class="keyword">if</span> (currType == WebView.class) {
                    args[k] = webView;
                    defValue = -<span class="number">1</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (currType == <span class="keyword">int</span>.class) {
                    args[k] = argsJson.getInt(k + defValue);
                } <span class="keyword">else</span> <span class="keyword">if</span> (currType == <span class="keyword">long</span>.class) {
                    <span class="comment">//WARN: argsJson.getLong(k + defValue) will return a bigger incorrect number</span>
                    args[k] = Long.parseLong(argsJson.getString(k + defValue));
                } <span class="keyword">else</span> <span class="keyword">if</span> (currType == <span class="keyword">boolean</span>.class) {
                    args[k] = argsJson.getBoolean(k + defValue);
                } <span class="keyword">else</span> <span class="keyword">if</span> (currType == Double.class) {
                    args[k] = argsJson.getDouble(k + defValue);
                } <span class="keyword">else</span> <span class="keyword">if</span> (currType == JSONObject.class) {
                    args[k] = argsJson.getJSONObject(k + defValue);
                } <span class="keyword">else</span> <span class="keyword">if</span> (currType == JsCallback.class) {
                    args[k] = <span class="keyword">new</span> JsCallback(webView, argsJson.getInt(k + defValue));
                } <span class="keyword">else</span> {    <span class="comment">//其他类型统一转换为字符串</span>
                    args[k] = argsJson.getString(k + defValue);
                }
            }
            <span class="keyword">return</span> getReturn(jsonStr, <span class="number">200</span>, currMethod.invoke(<span class="keyword">null</span>, args));
        } <span class="keyword">catch</span> (Exception e) {
            <span class="comment">//优先返回详细的错误信息</span>
            <span class="keyword">if</span> (e.getCause() != <span class="keyword">null</span>) {
                <span class="keyword">return</span> getReturn(jsonStr, <span class="number">500</span>, <span class="string">"method execute error:"</span> + e.getCause().getMessage());
            }
            <span class="keyword">return</span> getReturn(jsonStr, <span class="number">500</span>, <span class="string">"method execute error:"</span> + e.getMessage());
        }
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> getReturn(jsonStr, <span class="number">500</span>, <span class="string">"call data empty"</span>);
    }
}

<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">keyConcat</span> (String name, <span class="keyword">int</span> len) {
    <span class="keyword">return</span> name + <span class="string">"_"</span> + len;
}

<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getReturn</span> (String reqJson, <span class="keyword">int</span> stateCode, Object result) {
    String insertRes = String.valueOf(result);
    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> String) {
        insertRes = <span class="string">"\""</span> + insertRes + <span class="string">"\""</span>;
    }
    String resStr = String.format(RETURN_RESULT_FORMAT, stateCode, insertRes);
    Log.d(<span class="string">"HostApp call json: "</span> + reqJson + <span class="string">" result:"</span> + resStr);
    <span class="keyword">return</span> resStr;
}
</pre></td></tr></table></figure>

<p>这是一个完整的解析匹配过程，会将js层传入的参数个数、参数次序及类型与HostJsScope类的方法匹配，匹配成功则反射执行java方法，并返回函数执行的结果。这里有几点需要注意：</p>
<ul>
<li>方法反射执行时会将当前调用来源WebView的实例放到第一个参数，方便在HostJsScope静态方法拿到一些Context相关上下文；</li>
<li>JS层可传入的参数类型是多样的，可以是number、string、boolean、json、<strong>function</strong>，其中<strong>number数字为长整型时（如时间戳），必须先转为string类型</strong>，以避免数字传递误差；</li>
<li>Java方法的返回值可以是void 或 能被String.valueOf转换的类型（如int、long、String、double、float等）；</li>
<li>如果执行失败或找不到调用方法时，Java层会将异常信息传递到JS层， JS匿名函数中会throw抛出错误；</li>
</ul>
<h3 id="四、HostApp在页面的使用">四、HostApp在页面的使用</h3>
<p>有了上面的准备工作，现在我们在页面中就可以很方便地使用HostApp了，而不需要加载任何依赖文件。如li标签的点击：</p>
<figure class="highlight HTML"><figcaption><span>test.html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"entry"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">onclick</span>=<span class="value">"HostApp.alert('HostApp.alert');"</span>&gt;</span>HostApp.alert<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">onclick</span>=<span class="value">"HostApp.toast('HostApp.toast');"</span>&gt;</span>HostApp.toast<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">onclick</span>=<span class="value">"HostApp.testLossTime(new Date().getTime() + '');"</span>&gt;</span>HostApp.testLossTime<span class="tag">&lt;/<span class="title">li</span>&gt;</span> <span class="comment">&lt;!-- 时间戳长整型调用前先转换为string --&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">onclick</span>=<span class="value">"HostApp.toast(HostApp.getIMSI());"</span>&gt;</span>HostApp.getIMSI<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure>

<p>但同时有一种业务情景时，页面初始加载完备时就应立即触发的调用，如果我们这样写：</p>
<figure class="highlight JAVASCRIPT"><figcaption><span>test.html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>document.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    HostApp.toast(<span class="string">'document ready now'</span>);;
}, <span class="literal">false</span>);
</pre></td></tr></table></figure>

<p>那么HostApp的调用极有可能不成功，因为端注入HostApp JS片段的时机可能在document.ready前也可能在其后。那么如何解决这个矛盾的问题呢？</p>
<p>如果document.ready的时候HostApp JS已经注入成功，这种情况OK没有问题。当document.ready的时候HostApp JS还未开始注入，这种情景下我们的js脚本层就需要做出变动，即轮询状态，直到端注入成功或者超时（1.5s），再发生回调。具体实现如下（下面的是以zepto.js的$.ready()函数改造为例）。</p>
<figure class="highlight JAVASCRIPT"><figcaption><span>zepto.js</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">//针对DOM的一些操作</span>
<span class="comment">// Define methods that will be available on all</span>
<span class="comment">// Zepto collections</span>
$.fn = {
    <span class="comment">//DOM Ready</span>
    ready: <span class="function"><span class="keyword">function</span><span class="params">(callback, jumpHostAppInject)</span> {</span>
        <span class="keyword">var</span> originCb = callback;
        <span class="keyword">var</span> mcounter = <span class="number">0</span>;
        <span class="comment">//尝试等待(1500ms超时)让端注入HostApp Js</span>
        callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">if</span>(!window.HostApp && mcounter++ <span class="xml"><span class="tag">&lt; <span class="attribute">150</span>)<span class="attribute">setTimeout</span>(<span class="attribute">callback</span>, <span class="attribute">10</span>);<span class="attribute">else</span> <span class="attribute">originCb</span>($);
        };
        //是否跳过等待<span class="attribute">HostApp</span>的注入
        <span class="attribute">if</span> (<span class="attribute">jumpHostAppInject</span>) {
            <span class="attribute">callback</span> = <span class="attribute">originCb</span>;
        }
        <span class="attribute">if</span> (<span class="attribute">readyRE.test</span>(<span class="attribute">document.readyState</span>)) <span class="attribute">callback</span>($); <span class="attribute">else</span> <span class="attribute">document.addEventListener</span>('<span class="attribute">DOMContentLoaded</span>', <span class="attribute">function</span>() {
                <span class="attribute">callback</span>($)
            }, <span class="attribute">false</span>);
        <span class="attribute">return</span> <span class="attribute">this</span>
    },
    <span class="attribute">...</span>
    <span class="attribute">...</span>
};</span></span>
</pre></td></tr></table></figure>

<p>这样的机制也就解释了为什么不把Java层的JS注入放在OnPageFinish了，如果那样页面轮询的次数就会上升等待的时间就会变长，而且有可能会超时。好了，有了上面的改动，页面初始加载完备时需要立即触发HostApp的调用，如下：</p>
<figure class="highlight JAVASCRIPT"><figcaption><span>test.html</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>&lt;script type=<span class="string">"text/javascript"</span>&gt;
    $(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        HostApp.alert(<span class="string">"document ready now"</span>);
        <span class="keyword">if</span> (HostApp.existVerticalScrollbar()) {
            HostApp.setOnScrollBottomListener (<span class="number">40</span>, <span class="function"><span class="keyword">function</span> <span class="params">(contentHeight)</span> {</span>
                HostApp.toast(<span class="string">"reach content(height "</span> + contentHeight + <span class="string">") bottom"</span>);
            });
        }
    });
<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>最后，文章所引用的完整源代码见：<a href="https://github.com/pedant/safe-java-for-webview-js" target="_blank" rel="external">Safe Java-JS Bridge In Android WebView[Github]</a></p>
<p><strong>转载请注明出处链接，谢谢！！！</strong></p>

      
    </div>
  
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/android/">android</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  
  </div>
</article>


<section id="comment">
<!-- Duoshuo Comment BEGIN -->
	<div class="ds-thread"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"pedant"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>
<!-- Duoshuo Comment END -->
</section>

</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:www.pedant.cn">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/android/">android</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/SQLite/">SQLite</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>2</small></li>
  
    <li><a href="/tags/javascript/">javascript</a><small>1</small></li>
  
    <li><a href="/tags/webview/">webview</a><small>1</small></li>
  
    <li><a href="/tags/攻防安全/">攻防安全</a><small>1</small></li>
  
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
    <li><a href="http://blog.csdn.net/Luoshengyang/" title="老罗的Android之旅">老罗的Android之旅</a></li>
    <li><a href="http://winterland.me/" title="冬的实验室">冬的实验室</a></li>
    <li><a href="http://blog.codingnow.com/" title="云风的BLOG">云风的BLOG</a></li>
</ul>
</div>

</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2014 Yanyuetian
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>





<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>
  <!-- Baidu Button BEGIN -->
    <script type="text/javascript" id="bdshare_js" data="type=slide&amp;img=1&amp;mini=1&amp;pos=left&amp;uid=6871901" ></script>
    <script type="text/javascript" id="bdshell_js"></script>
    <script type="text/javascript" src="/js/bds_animate.js"></script>
    <script type="text/javascript">
    var bds_config={"bdTop":0};
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
    </script>
 <!-- Baidu Button END -->

</body>
</html>
